# 函数作用域和块作用域

### 3.1 函数中的作用域

函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)。

### 3.2 隐藏内部实现

从所写的代码中挑选出一个任意的片段，然后用函数声明的方式对他进行包装，实际上就是把这些代码“隐藏”起来了。

为什么隐藏？

它们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API 设计。

规避冲突

可以避免同名标识符之间的冲突

1.全局命名空间

一个名字足够独特的变量，通常是一个对象。

2.模块管理

模块管理器，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。

### 3.3 函数作用域

区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置(不仅仅是一行代码，而是整个声明中的位置)。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。

3.3.1 匿名和具名

匿名函数表达式，没有名称标识符。

```
  setTimeout(function() {
    console.log('Hello')
  }, 1000);
```

缺点：

1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。

2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。

3. 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。

行内函数表达式

3.3.2 立即执行函数表达式


### 3.4 块作用域

块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息 扩展为在块中隐藏信息。

块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块(通常指 { .. } 内部)。


#### with

#### try/catch

#### let

let 关键字可以将变量绑定到所在的任意作用域中(通常是 {.. } 内部)。换句话说，let 为其声明的变量隐式地劫持了所在的块作用域。

1. 垃圾收集

2. let循环
3. 
```
for (let i=0; i<10; i++) { 
    console.log( i );
}
console.log( i ); // ReferenceError
```

#### const 
创建块作用域变量，但其值是固定的（常量）。